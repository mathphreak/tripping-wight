Demoes Midi

make a SoundSheet

make a TimeEventContainerSequencer (WTF???)
private const sequencer: TimeEventContainerSequencer = new TimeEventContainerSequencer( Midi.SCHUMANN.toTimeEventContainer( 1.0 / 128.0 ) );
make a PolySynth with a SoundSheetVoiceFactory from our SoundSheet

clear the PolySynth
stop playing audio (look where the driver variable came from in the as file)
restart the audio position

if we haven't disposed of the old sound:
	get rid of it

get the new sound (SoundDecoder.MP3_LAME_OFFSET means something)
tell it to let us know when it makes progress
and also when it finishes
and load "load/piano.mp3"

when the sound makes progress:
	update the UI to reflect that

when the sound finishes loading:
	tell the user how large it is
	
	start playing audio
	
	tell the sound sheet about the sound
	
	if we haven't wired everything:
		TimeEventContainerSequencer out => PolySynth note in
		PolySynth out => master output
		add to the engine's processors both things

import tonfall.core.Engine;
import tonfall.core.Memory;
import tonfall.core.Signal;
import tonfall.core.TimeConversion;
import tonfall.core.TimeEvent;
import tonfall.core.TimeEventNote;
import tonfall.core.noteToFrequency;
import tonfall.format.IAudioDecoder;
import tonfall.prefab.poly.IPolySynthVoice;
import tonfall.prefab.poly.IPolySynthVoiceFactory;
import tonfall.util.ISoundSheet;

final class SoundSheet
	implements ISoundSheet
{
	public static const FREQUENCIES: Vector.<Number> = createFrequencyTable();

	private static function createFrequencyTable(): Vector.<Number>
	{
		const table: Vector.<Number> = new Vector.<Number>( 11, true );
		
		for( var i: int = 0 ; i < 11 ; ++i )
		{
			table[i] = noteToFrequency( 36 + i * 6 );
		}

		return table;
	}
	
	private var _decoder: IAudioDecoder;

	public function setDecoder( decoder: IAudioDecoder ): void
	{
		_decoder = decoder;
	}

	public function getNearestKeyIndexByNote( note: int ): int
	{
		var index: int = ( note - 36.0 ) / 6.0 + 0.5;

		if( index < 0 )
			index = 0;
		else
		if( index > 10 )
			index = 10;
			
		return index;
	}

	public function getFrequencyByKeyIndex( keyIndex: int ): Number
	{
		return FREQUENCIES[ keyIndex ];
	}

	public function get numSamplesEachKey(): Number
	{
		return 44100.0;
	}

	public function get decoder(): IAudioDecoder
	{
		return _decoder;
	}

	public function getStartPositionFromKeyIndex( keyIndex: int ): Number
	{
		return keyIndex * numSamplesEachKey;
	}

	public function getEndPositionFromKeyIndex( keyIndex: int ): Number
	{
		return ( keyIndex + 1 ) * numSamplesEachKey;
	}
}

final class SoundSheetVoiceFactory
	implements IPolySynthVoiceFactory
{
	private var _sheet: ISoundSheet;

	public function SoundSheetVoiceFactory( sheet: ISoundSheet )
	{
		_sheet = sheet;
	}
	
	public function create( event: TimeEventNote ): IPolySynthVoice
	{
		return new SoundSheetVoice( _sheet );
	}
}

final class SoundSheetVoice
	implements IPolySynthVoice
{
	// Lazy envelope built
	private const engine: Engine = Engine.getInstance();
	private const RELEASE_DURATION: int = 8820; // 200ms

	private var _rate: Number;
	private var _position: Number;
	private var _end: Number;
	private var _envelopePointer: int;
	private var _sheet: ISoundSheet;
	private var _velocity: Number;

	public function SoundSheetVoice( sheet: ISoundSheet )
	{
		_sheet = sheet;
	}
	
	public function start( event: TimeEvent ): void
	{
		const note: int = TimeEventNote( event ).note;

		const keyIndex: int = _sheet.getNearestKeyIndexByNote( note );
		
		const sampleFrequency: Number = _sheet.getFrequencyByKeyIndex( keyIndex );
		const noteFrequency: Number = noteToFrequency( note );

		_rate = noteFrequency / sampleFrequency;

		_position = _sheet.getStartPositionFromKeyIndex( keyIndex );
		_end = _sheet.getEndPositionFromKeyIndex( keyIndex );
		
		_velocity = TimeEventNote( event ).velocity;
		
		_envelopePointer = TimeConversion.barsToNumSamples( TimeEventNote( event ).barDuration, engine.bpm );
	}

	public function stop(): void
	{
	}

	public function processAdd( current: Signal, numSignals: int ): Boolean
	{
		//-- REUSE INSTEAD OF RECREATION
		Memory.position = 0;
		
		var p0: Number = _position;
		var p1: Number =  p0 + numSignals * _rate;
		
		if( p1 > _end )
			p1 = _end;

		const i0: int = p0;
		const i1: int = p1 + 2.0;
		
		//-- EXTRACT SAMPLES
		_sheet.decoder.extract( Memory, i1 - i0, i0 );
		
		var l0: Number;
		var r0: Number;
		var l1: Number;
		var r1: Number;
		
		var bufferPosition: Number = p0 - i0;
		
		var integer: int;
		var alpha: Number;
		var env: Number;

		for( var i: int = 0 ; i < numSignals ; ++i )
		{
			_position += _rate;

			if( _position >= _end )
				return true;
				
			if( 0 < _envelopePointer-- )
				env = 1.0;
			else
			if( -RELEASE_DURATION > _envelopePointer )
				return true;
			else
				env = 1.0 + _envelopePointer / RELEASE_DURATION;
			
			env *= _velocity;

			integer = bufferPosition;
			alpha = bufferPosition - integer;
			bufferPosition += _rate;

			//-- SET TARGET READ POSITION
			Memory.position = integer << 3;

			//-- READ TWO STEREO SAMPLES FOR LINEAR INTERPOLATION
			l0 = Memory.readFloat();
			r0 = Memory.readFloat();

			l1 = Memory.readFloat();
			r1 = Memory.readFloat();
			
			//-- WRITE INTERPOLATED AMPLITUDES INTO STREAM
			current.l += ( l0 + alpha * ( l1 - l0 ) ) * env;
			current.r += ( r0 + alpha * ( r1 - r0 ) ) * env;
			current = current.next;
		}
		
		return false;
	}

	public function dispose(): void
	{
		_sheet = null;
	}
}
